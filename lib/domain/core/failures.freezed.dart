// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  UnknownCurrency<T> unknownEnum<T>({required T failedValue}) {
    return UnknownCurrency<T>(
      failedValue: failedValue,
    );
  }

  CurrencyTooBig<T> currencyValueTooBig<T>(
      {required double max, required T failedValue}) {
    return CurrencyTooBig<T>(
      max: max,
      failedValue: failedValue,
    );
  }

  CurrencyTooSmall<T> currencyValueTooSmall<T>(
      {required double min, required T failedValue}) {
    return CurrencyTooSmall<T>(
      min: min,
      failedValue: failedValue,
    );
  }

  PasswordsNotEqual<T> passwordsNotEqual<T>({required T failedValue}) {
    return PasswordsNotEqual<T>(
      failedValue: failedValue,
    );
  }

  CurrencyValueNotInteger<T> currencyValueNotInteger<T>(
      {required T failedValue}) {
    return CurrencyValueNotInteger<T>(
      failedValue: failedValue,
    );
  }

  CurrencyPriceTooBig<T> currencyPriceTooBig<T>(
      {required double max, required T failedValue}) {
    return CurrencyPriceTooBig<T>(
      max: max,
      failedValue: failedValue,
    );
  }

  CurrencyPriceTooSmall<T> currencyPriceTooSmall<T>({required T failedValue}) {
    return CurrencyPriceTooSmall<T>(
      failedValue: failedValue,
    );
  }

  InvalidStringToDouble<T> invalidStringToDouble<T>({required T failedValue}) {
    return InvalidStringToDouble<T>(
      failedValue: failedValue,
    );
  }

  InvalidEmail<T> invalidEmail<T>({required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  ShortPassword<T> shortPassword<T>({required T failedValue}) {
    return ShortPassword<T>(
      failedValue: failedValue,
    );
  }

  InvalidDate<T> invalidDate<T>({required T failedValue}) {
    return InvalidDate<T>(
      failedValue: failedValue,
    );
  }

  DateIsUTC<T> dateIsUTC<T>({required T failedValue}) {
    return DateIsUTC<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedValue => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc
abstract class $UnknownCurrencyCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $UnknownCurrencyCopyWith(
          UnknownCurrency<T> value, $Res Function(UnknownCurrency<T>) then) =
      _$UnknownCurrencyCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$UnknownCurrencyCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $UnknownCurrencyCopyWith<T, $Res> {
  _$UnknownCurrencyCopyWithImpl(
      UnknownCurrency<T> _value, $Res Function(UnknownCurrency<T>) _then)
      : super(_value, (v) => _then(v as UnknownCurrency<T>));

  @override
  UnknownCurrency<T> get _value => super._value as UnknownCurrency<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(UnknownCurrency<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$UnknownCurrency<T> implements UnknownCurrency<T> {
  const _$UnknownCurrency({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.unknownEnum(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UnknownCurrency<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnknownCurrencyCopyWith<T, UnknownCurrency<T>> get copyWith =>
      _$UnknownCurrencyCopyWithImpl<T, UnknownCurrency<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return unknownEnum(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return unknownEnum?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (unknownEnum != null) {
      return unknownEnum(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return unknownEnum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return unknownEnum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (unknownEnum != null) {
      return unknownEnum(this);
    }
    return orElse();
  }
}

abstract class UnknownCurrency<T> implements ValueFailure<T> {
  const factory UnknownCurrency({required T failedValue}) =
      _$UnknownCurrency<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $UnknownCurrencyCopyWith<T, UnknownCurrency<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CurrencyTooBigCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $CurrencyTooBigCopyWith(
          CurrencyTooBig<T> value, $Res Function(CurrencyTooBig<T>) then) =
      _$CurrencyTooBigCopyWithImpl<T, $Res>;
  @override
  $Res call({double max, T failedValue});
}

/// @nodoc
class _$CurrencyTooBigCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $CurrencyTooBigCopyWith<T, $Res> {
  _$CurrencyTooBigCopyWithImpl(
      CurrencyTooBig<T> _value, $Res Function(CurrencyTooBig<T>) _then)
      : super(_value, (v) => _then(v as CurrencyTooBig<T>));

  @override
  CurrencyTooBig<T> get _value => super._value as CurrencyTooBig<T>;

  @override
  $Res call({
    Object? max = freezed,
    Object? failedValue = freezed,
  }) {
    return _then(CurrencyTooBig<T>(
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$CurrencyTooBig<T> implements CurrencyTooBig<T> {
  const _$CurrencyTooBig({required this.max, required this.failedValue});

  @override
  final double max;
  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.currencyValueTooBig(max: $max, failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CurrencyTooBig<T> &&
            const DeepCollectionEquality().equals(other.max, max) &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(max),
      const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $CurrencyTooBigCopyWith<T, CurrencyTooBig<T>> get copyWith =>
      _$CurrencyTooBigCopyWithImpl<T, CurrencyTooBig<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return currencyValueTooBig(max, failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return currencyValueTooBig?.call(max, failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyValueTooBig != null) {
      return currencyValueTooBig(max, failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return currencyValueTooBig(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return currencyValueTooBig?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyValueTooBig != null) {
      return currencyValueTooBig(this);
    }
    return orElse();
  }
}

abstract class CurrencyTooBig<T> implements ValueFailure<T> {
  const factory CurrencyTooBig({required double max, required T failedValue}) =
      _$CurrencyTooBig<T>;

  double get max;
  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $CurrencyTooBigCopyWith<T, CurrencyTooBig<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CurrencyTooSmallCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $CurrencyTooSmallCopyWith(
          CurrencyTooSmall<T> value, $Res Function(CurrencyTooSmall<T>) then) =
      _$CurrencyTooSmallCopyWithImpl<T, $Res>;
  @override
  $Res call({double min, T failedValue});
}

/// @nodoc
class _$CurrencyTooSmallCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $CurrencyTooSmallCopyWith<T, $Res> {
  _$CurrencyTooSmallCopyWithImpl(
      CurrencyTooSmall<T> _value, $Res Function(CurrencyTooSmall<T>) _then)
      : super(_value, (v) => _then(v as CurrencyTooSmall<T>));

  @override
  CurrencyTooSmall<T> get _value => super._value as CurrencyTooSmall<T>;

  @override
  $Res call({
    Object? min = freezed,
    Object? failedValue = freezed,
  }) {
    return _then(CurrencyTooSmall<T>(
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double,
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$CurrencyTooSmall<T> implements CurrencyTooSmall<T> {
  const _$CurrencyTooSmall({required this.min, required this.failedValue});

  @override
  final double min;
  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.currencyValueTooSmall(min: $min, failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CurrencyTooSmall<T> &&
            const DeepCollectionEquality().equals(other.min, min) &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(min),
      const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $CurrencyTooSmallCopyWith<T, CurrencyTooSmall<T>> get copyWith =>
      _$CurrencyTooSmallCopyWithImpl<T, CurrencyTooSmall<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return currencyValueTooSmall(min, failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return currencyValueTooSmall?.call(min, failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyValueTooSmall != null) {
      return currencyValueTooSmall(min, failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return currencyValueTooSmall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return currencyValueTooSmall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyValueTooSmall != null) {
      return currencyValueTooSmall(this);
    }
    return orElse();
  }
}

abstract class CurrencyTooSmall<T> implements ValueFailure<T> {
  const factory CurrencyTooSmall(
      {required double min, required T failedValue}) = _$CurrencyTooSmall<T>;

  double get min;
  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $CurrencyTooSmallCopyWith<T, CurrencyTooSmall<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PasswordsNotEqualCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $PasswordsNotEqualCopyWith(PasswordsNotEqual<T> value,
          $Res Function(PasswordsNotEqual<T>) then) =
      _$PasswordsNotEqualCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$PasswordsNotEqualCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $PasswordsNotEqualCopyWith<T, $Res> {
  _$PasswordsNotEqualCopyWithImpl(
      PasswordsNotEqual<T> _value, $Res Function(PasswordsNotEqual<T>) _then)
      : super(_value, (v) => _then(v as PasswordsNotEqual<T>));

  @override
  PasswordsNotEqual<T> get _value => super._value as PasswordsNotEqual<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(PasswordsNotEqual<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$PasswordsNotEqual<T> implements PasswordsNotEqual<T> {
  const _$PasswordsNotEqual({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.passwordsNotEqual(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PasswordsNotEqual<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $PasswordsNotEqualCopyWith<T, PasswordsNotEqual<T>> get copyWith =>
      _$PasswordsNotEqualCopyWithImpl<T, PasswordsNotEqual<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return passwordsNotEqual(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return passwordsNotEqual?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (passwordsNotEqual != null) {
      return passwordsNotEqual(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return passwordsNotEqual(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return passwordsNotEqual?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (passwordsNotEqual != null) {
      return passwordsNotEqual(this);
    }
    return orElse();
  }
}

abstract class PasswordsNotEqual<T> implements ValueFailure<T> {
  const factory PasswordsNotEqual({required T failedValue}) =
      _$PasswordsNotEqual<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $PasswordsNotEqualCopyWith<T, PasswordsNotEqual<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CurrencyValueNotIntegerCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $CurrencyValueNotIntegerCopyWith(CurrencyValueNotInteger<T> value,
          $Res Function(CurrencyValueNotInteger<T>) then) =
      _$CurrencyValueNotIntegerCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$CurrencyValueNotIntegerCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $CurrencyValueNotIntegerCopyWith<T, $Res> {
  _$CurrencyValueNotIntegerCopyWithImpl(CurrencyValueNotInteger<T> _value,
      $Res Function(CurrencyValueNotInteger<T>) _then)
      : super(_value, (v) => _then(v as CurrencyValueNotInteger<T>));

  @override
  CurrencyValueNotInteger<T> get _value =>
      super._value as CurrencyValueNotInteger<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(CurrencyValueNotInteger<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$CurrencyValueNotInteger<T> implements CurrencyValueNotInteger<T> {
  const _$CurrencyValueNotInteger({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.currencyValueNotInteger(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CurrencyValueNotInteger<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $CurrencyValueNotIntegerCopyWith<T, CurrencyValueNotInteger<T>>
      get copyWith =>
          _$CurrencyValueNotIntegerCopyWithImpl<T, CurrencyValueNotInteger<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return currencyValueNotInteger(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return currencyValueNotInteger?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyValueNotInteger != null) {
      return currencyValueNotInteger(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return currencyValueNotInteger(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return currencyValueNotInteger?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyValueNotInteger != null) {
      return currencyValueNotInteger(this);
    }
    return orElse();
  }
}

abstract class CurrencyValueNotInteger<T> implements ValueFailure<T> {
  const factory CurrencyValueNotInteger({required T failedValue}) =
      _$CurrencyValueNotInteger<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $CurrencyValueNotIntegerCopyWith<T, CurrencyValueNotInteger<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CurrencyPriceTooBigCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $CurrencyPriceTooBigCopyWith(CurrencyPriceTooBig<T> value,
          $Res Function(CurrencyPriceTooBig<T>) then) =
      _$CurrencyPriceTooBigCopyWithImpl<T, $Res>;
  @override
  $Res call({double max, T failedValue});
}

/// @nodoc
class _$CurrencyPriceTooBigCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $CurrencyPriceTooBigCopyWith<T, $Res> {
  _$CurrencyPriceTooBigCopyWithImpl(CurrencyPriceTooBig<T> _value,
      $Res Function(CurrencyPriceTooBig<T>) _then)
      : super(_value, (v) => _then(v as CurrencyPriceTooBig<T>));

  @override
  CurrencyPriceTooBig<T> get _value => super._value as CurrencyPriceTooBig<T>;

  @override
  $Res call({
    Object? max = freezed,
    Object? failedValue = freezed,
  }) {
    return _then(CurrencyPriceTooBig<T>(
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$CurrencyPriceTooBig<T> implements CurrencyPriceTooBig<T> {
  const _$CurrencyPriceTooBig({required this.max, required this.failedValue});

  @override
  final double max;
  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.currencyPriceTooBig(max: $max, failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CurrencyPriceTooBig<T> &&
            const DeepCollectionEquality().equals(other.max, max) &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(max),
      const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $CurrencyPriceTooBigCopyWith<T, CurrencyPriceTooBig<T>> get copyWith =>
      _$CurrencyPriceTooBigCopyWithImpl<T, CurrencyPriceTooBig<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return currencyPriceTooBig(max, failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return currencyPriceTooBig?.call(max, failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyPriceTooBig != null) {
      return currencyPriceTooBig(max, failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return currencyPriceTooBig(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return currencyPriceTooBig?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyPriceTooBig != null) {
      return currencyPriceTooBig(this);
    }
    return orElse();
  }
}

abstract class CurrencyPriceTooBig<T> implements ValueFailure<T> {
  const factory CurrencyPriceTooBig(
      {required double max, required T failedValue}) = _$CurrencyPriceTooBig<T>;

  double get max;
  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $CurrencyPriceTooBigCopyWith<T, CurrencyPriceTooBig<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CurrencyPriceTooSmallCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $CurrencyPriceTooSmallCopyWith(CurrencyPriceTooSmall<T> value,
          $Res Function(CurrencyPriceTooSmall<T>) then) =
      _$CurrencyPriceTooSmallCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$CurrencyPriceTooSmallCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $CurrencyPriceTooSmallCopyWith<T, $Res> {
  _$CurrencyPriceTooSmallCopyWithImpl(CurrencyPriceTooSmall<T> _value,
      $Res Function(CurrencyPriceTooSmall<T>) _then)
      : super(_value, (v) => _then(v as CurrencyPriceTooSmall<T>));

  @override
  CurrencyPriceTooSmall<T> get _value =>
      super._value as CurrencyPriceTooSmall<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(CurrencyPriceTooSmall<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$CurrencyPriceTooSmall<T> implements CurrencyPriceTooSmall<T> {
  const _$CurrencyPriceTooSmall({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.currencyPriceTooSmall(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CurrencyPriceTooSmall<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $CurrencyPriceTooSmallCopyWith<T, CurrencyPriceTooSmall<T>> get copyWith =>
      _$CurrencyPriceTooSmallCopyWithImpl<T, CurrencyPriceTooSmall<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return currencyPriceTooSmall(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return currencyPriceTooSmall?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyPriceTooSmall != null) {
      return currencyPriceTooSmall(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return currencyPriceTooSmall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return currencyPriceTooSmall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (currencyPriceTooSmall != null) {
      return currencyPriceTooSmall(this);
    }
    return orElse();
  }
}

abstract class CurrencyPriceTooSmall<T> implements ValueFailure<T> {
  const factory CurrencyPriceTooSmall({required T failedValue}) =
      _$CurrencyPriceTooSmall<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $CurrencyPriceTooSmallCopyWith<T, CurrencyPriceTooSmall<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidStringToDoubleCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidStringToDoubleCopyWith(InvalidStringToDouble<T> value,
          $Res Function(InvalidStringToDouble<T>) then) =
      _$InvalidStringToDoubleCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidStringToDoubleCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidStringToDoubleCopyWith<T, $Res> {
  _$InvalidStringToDoubleCopyWithImpl(InvalidStringToDouble<T> _value,
      $Res Function(InvalidStringToDouble<T>) _then)
      : super(_value, (v) => _then(v as InvalidStringToDouble<T>));

  @override
  InvalidStringToDouble<T> get _value =>
      super._value as InvalidStringToDouble<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidStringToDouble<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidStringToDouble<T> implements InvalidStringToDouble<T> {
  const _$InvalidStringToDouble({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidStringToDouble(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidStringToDouble<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidStringToDoubleCopyWith<T, InvalidStringToDouble<T>> get copyWith =>
      _$InvalidStringToDoubleCopyWithImpl<T, InvalidStringToDouble<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return invalidStringToDouble(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return invalidStringToDouble?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (invalidStringToDouble != null) {
      return invalidStringToDouble(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return invalidStringToDouble(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return invalidStringToDouble?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (invalidStringToDouble != null) {
      return invalidStringToDouble(this);
    }
    return orElse();
  }
}

abstract class InvalidStringToDouble<T> implements ValueFailure<T> {
  const factory InvalidStringToDouble({required T failedValue}) =
      _$InvalidStringToDouble<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidStringToDoubleCopyWith<T, InvalidStringToDouble<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidEmail<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({required T failedValue}) = _$InvalidEmail<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ShortPassword<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return shortPassword?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return shortPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword({required T failedValue}) = _$ShortPassword<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidDateCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidDateCopyWith(
          InvalidDate<T> value, $Res Function(InvalidDate<T>) then) =
      _$InvalidDateCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDateCopyWith<T, $Res> {
  _$InvalidDateCopyWithImpl(
      InvalidDate<T> _value, $Res Function(InvalidDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidDate<T>));

  @override
  InvalidDate<T> get _value => super._value as InvalidDate<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidDate<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidDate<T> implements InvalidDate<T> {
  const _$InvalidDate({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidDate<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith =>
      _$InvalidDateCopyWithImpl<T, InvalidDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return invalidDate?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return invalidDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate<T> implements ValueFailure<T> {
  const factory InvalidDate({required T failedValue}) = _$InvalidDate<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DateIsUTCCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $DateIsUTCCopyWith(
          DateIsUTC<T> value, $Res Function(DateIsUTC<T>) then) =
      _$DateIsUTCCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$DateIsUTCCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $DateIsUTCCopyWith<T, $Res> {
  _$DateIsUTCCopyWithImpl(
      DateIsUTC<T> _value, $Res Function(DateIsUTC<T>) _then)
      : super(_value, (v) => _then(v as DateIsUTC<T>));

  @override
  DateIsUTC<T> get _value => super._value as DateIsUTC<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(DateIsUTC<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$DateIsUTC<T> implements DateIsUTC<T> {
  const _$DateIsUTC({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.dateIsUTC(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DateIsUTC<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $DateIsUTCCopyWith<T, DateIsUTC<T>> get copyWith =>
      _$DateIsUTCCopyWithImpl<T, DateIsUTC<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) unknownEnum,
    required TResult Function(double max, T failedValue) currencyValueTooBig,
    required TResult Function(double min, T failedValue) currencyValueTooSmall,
    required TResult Function(T failedValue) passwordsNotEqual,
    required TResult Function(T failedValue) currencyValueNotInteger,
    required TResult Function(double max, T failedValue) currencyPriceTooBig,
    required TResult Function(T failedValue) currencyPriceTooSmall,
    required TResult Function(T failedValue) invalidStringToDouble,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
    required TResult Function(T failedValue) invalidDate,
    required TResult Function(T failedValue) dateIsUTC,
  }) {
    return dateIsUTC(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
  }) {
    return dateIsUTC?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? unknownEnum,
    TResult Function(double max, T failedValue)? currencyValueTooBig,
    TResult Function(double min, T failedValue)? currencyValueTooSmall,
    TResult Function(T failedValue)? passwordsNotEqual,
    TResult Function(T failedValue)? currencyValueNotInteger,
    TResult Function(double max, T failedValue)? currencyPriceTooBig,
    TResult Function(T failedValue)? currencyPriceTooSmall,
    TResult Function(T failedValue)? invalidStringToDouble,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    TResult Function(T failedValue)? invalidDate,
    TResult Function(T failedValue)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (dateIsUTC != null) {
      return dateIsUTC(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnknownCurrency<T> value) unknownEnum,
    required TResult Function(CurrencyTooBig<T> value) currencyValueTooBig,
    required TResult Function(CurrencyTooSmall<T> value) currencyValueTooSmall,
    required TResult Function(PasswordsNotEqual<T> value) passwordsNotEqual,
    required TResult Function(CurrencyValueNotInteger<T> value)
        currencyValueNotInteger,
    required TResult Function(CurrencyPriceTooBig<T> value) currencyPriceTooBig,
    required TResult Function(CurrencyPriceTooSmall<T> value)
        currencyPriceTooSmall,
    required TResult Function(InvalidStringToDouble<T> value)
        invalidStringToDouble,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(InvalidDate<T> value) invalidDate,
    required TResult Function(DateIsUTC<T> value) dateIsUTC,
  }) {
    return dateIsUTC(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
  }) {
    return dateIsUTC?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnknownCurrency<T> value)? unknownEnum,
    TResult Function(CurrencyTooBig<T> value)? currencyValueTooBig,
    TResult Function(CurrencyTooSmall<T> value)? currencyValueTooSmall,
    TResult Function(PasswordsNotEqual<T> value)? passwordsNotEqual,
    TResult Function(CurrencyValueNotInteger<T> value)? currencyValueNotInteger,
    TResult Function(CurrencyPriceTooBig<T> value)? currencyPriceTooBig,
    TResult Function(CurrencyPriceTooSmall<T> value)? currencyPriceTooSmall,
    TResult Function(InvalidStringToDouble<T> value)? invalidStringToDouble,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(InvalidDate<T> value)? invalidDate,
    TResult Function(DateIsUTC<T> value)? dateIsUTC,
    required TResult orElse(),
  }) {
    if (dateIsUTC != null) {
      return dateIsUTC(this);
    }
    return orElse();
  }
}

abstract class DateIsUTC<T> implements ValueFailure<T> {
  const factory DateIsUTC({required T failedValue}) = _$DateIsUTC<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $DateIsUTCCopyWith<T, DateIsUTC<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
